\chapter{Binary Search Complete Implementation}
\label{binappendix}
The best way to implement the tree data structure is to create a class for the nodes (\textbf{Node}) and a class for the binary tree (\textbf{BinaryTree}). As all the nodes of a binary trees has at most two children, in the class \textbf{Node} is enough to have three attributes: the value of the node, the left, and the right child, in turn of \textbf{Node} type as well. This way of implement tree is very similar to the one used for the \hyperref[linked list]{} linked list (\ref{linkedlist}).

\begin{lstlisting}[firstnumber=1, caption={Class definition for a node and a tree.}]
class Node():

	def __init__(self, value):
		self.value = value
		self.left = None
		self.right = None

class BinaryTree():

	def __init__(self, root):
		self.root = Node(root)
\end{lstlisting}

In this appendix there is a detailed implementation, both recursive and iterative, of all possible ways to perform a tree traversal in the case of \textbf{depth-first search}: pre-order traversal \ref{preorderappendix}, in-order traversal \ref{inorderappendix}, and post-order traversal \ref{postorderappendix}. The convention followed here is to look up first at the left child always, and later look up the right one. The opposite approach is equivalent.

The pseudocode of the iterative implementations is taken from \cite{wikitreestrav}(\href{https://en.wikipedia.org/wiki/Tree_traversal}{Tree traversal, Wikipedia}).

\section{Pre-order Traversal}
\label{preorderappendix}
In the pre-order traversal every new node is first checked as visited, and the left subtree is traversed first, and later the right one. This process is repeated until all the nodes of the tree are visited (\ref{preorder}). 

For implementing the pre-order traversal iteratively a stack (\ref{stack}) is used. The steps are \cite{wikitreestrav}:

\begin{algorithm}[H]
	\DontPrintSemicolon
	\LinesNumbered
  	\SetKwFunction{FIterativePreorder}{Iterative-Preorder}
  	\SetKwFunction{FRecursivePreorder}{Recursive-Preorder}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FRecursivePreorder{$node$}}{
		\If{(\normalfont{node == \textbf{null}})}{
			\KwRet
		}
		visit(node)\;
		\FRecursivePreorder{$node.left$}\;
		\FRecursivePreorder{$node.right$}\;
  	}
  	\;
  	\Fn{\FIterativePreorder{$node$}}{
  			s $\leftarrow$ \textbf{empty stack}\;
  			s.push(node)\;
  			\While{(\normalfont{\textbf{not} s.isEmpty()})}{
				node $\leftarrow$ s.pop()\;
				visit(node)\;  			
  				\CommentSty{$/*$ Right child is pushed first so that left is processed first (LIFO) $*/$}\;
  				
  				\If{(\normalfont{node.right $\neq$ \textbf{null}})}{
  					s.push(node.right)\;
  				}
    	    	\If{(\normalfont{node.left $\neq$ \textbf{null}})}{
  					s.push(node.left)\;
  				}
        	}
  	}
\caption{Pre-order pseudocode.}
\end{algorithm}

\begin{lstlisting}[firstnumber=1, caption={Recursive and iterative implementation of pre-order traversal.}]
class BinaryTree():
	...

	def recursive_print_tree(self):
		return self.preorder_recursive_print(tree.root, "")[:-1]
	
	def iterative_print_tree(self):
		return self.preorder_search_iterative(self, tree.root, "")

	def preorder_search_recursive(self, start, find_val):
		if start:
			if start.value == find_val:
				return True
			self.preorder_search_recursive(start.left, find_val)
			self.preorder_search_recursive(start.right, find_val)

	def preorder_search_iterative(self, start, find_val):
		if start == None:
			return None
		visited = []		
		stack = []
		stack.push(start)
		while stack: # Keep cycle until the stack is empty
			node = stack.pop()
			visited.append(node)
			if node.value == find_val:
				return True
			# Right child is pushed first so that the left one is processed first
			if node.right:
				stack.append(node.right)
			if node.left:
				stack.append(node.right)
		return visited

	def preorder_recursive_print(self, start, traversal):
		if start:
			traversal += (str(start.value) + "-")
			traversal = self.preorder_recursive_print(start.left, traversal)
			traversal = self.preorder_recursive_print(start.right,traversal)
		return traversal
\end{lstlisting}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/appendix/images/appendixtree/treesappendix_1.pdf}
		\caption[Pre-order iterative example.]{Pre-order iterative example.}
		\label{appendixtrees_1}
	\end{center}
\end{figure}

\section{In-order Traversal}
\label{inorderappendix}
In the in-order traversal the first node to be checked is the first leaf of the left subtree. The second one is the parent of the first checked node, and then the right subtree is checked repeating the previous process. All this process is repeated until all the nodes are visited or the value is found \ref{inorder}. 

For implementing the in-order traversal iteratively a stack is used. The steps are \cite{wikitreestrav}:

\begin{algorithm}[H]
	\DontPrintSemicolon
	\LinesNumbered
  	\SetKwFunction{FIterativeInorder}{Iterative-Inorder}
  	\SetKwFunction{FRecursiveInorder}{Recursive-Inorder}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FRecursiveInorder{$node$}}{
		\If{(\normalfont{node == \textbf{null}})}{
			\KwRet
		}
		\FRecursiveInorder{$node.left$}\;
		visit(node)\;
		\FRecursiveInorder{$node.right$}\;
  	}
  	\;
  	\Fn{\FIterativeInorder{$node$}}{
  			s $\leftarrow$ \textbf{empty stack}\;
  			\While{(\normalfont{\textbf{not} s.isEmpty() \textbf{or} node $\neq$ \textbf{null}})}{
  				\If{(\normalfont{node $\neq$ \textbf{null}})}{
  					s.push(node)\;
  					node $\leftarrow$ node.left\;
  				}
    	    	\Else{
    	    		node $\leftarrow$ s.pop()\;
    	    		visit(node)\;
    	    		node $\leftarrow$ node.right\;
    	    	}
        	}
  	}
\caption{In-order pseudocode.}
\end{algorithm}

\begin{lstlisting}[firstnumber=1, caption={Recursive and iterative implementation of in-order traversal.}]
class BinaryTree():
	...

	def recursive_print_tree(self):
		return self.inorder_recursive_print(tree.root, "")[:-1]
	
	def iterative_print_tree(self):
		return self.inorder_search_iterative(self, tree.root, "")

	def inorder_search_recursive(self, start, find_val):
		if start:
			self.inorder_search_recursive(start.left, find_val)
			if start.value == find_val:
				return True
			self.inorder_search_recursive(start.right, find_val)

	def inorder_search_iterative(self, start, find_val):
		if start == None:
			return None
		stack = []
		stack.append(start)
		current = start
		visited = []
		while stack or current != None:
			if current != None:
				stack.append(current)
				current = current.left
			else:
				current = stack.pop()
				if current.value == find_val:
					return True
				visited.append(current)
				current = current.right
		return visited		
		
	def inorder_recursive_print(self, start, traversal):
		if start:
			traversal = self.inorder_recursive_print(start.left, traversal)
			traversal += (str(start.value) + "-")
			traversal = self.inorder_recursive_print(start.right,traversal)
		return traversal
\end{lstlisting}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/appendix/images/appendixtree/treesappendix_2.pdf}
		\caption[In-order iterative example.]{In-order iterative example.}
		\label{appendixtrees_2}
	\end{center}
\end{figure}

\section{Post-order Traversal}
\label{postorderappendix}
In the post-order traversal the first node to be checked is the first leaf of the left subtree. The second node is the right node of the parent of the first checked node. Once checked the right side of the subtree also the parent is checked and the process is repeated until all the node are visited or the value is found \ref{postorder}. 

Also in this case for implementing the post-order traversal iteratively a stack is used. The steps are \cite{wikitreestrav}:

\begin{algorithm}[H]
	\DontPrintSemicolon
	\LinesNumbered
  	\SetKwFunction{FIterativePostorder}{Iterative-Postorder}
  	\SetKwFunction{FRecursivePostorder}{Recursive-Postorder}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FRecursivePostorder{$node$}}{
		\If{(\normalfont{node == \textbf{null}})}{
			\KwRet
		}
		\FRecursivePostorder{$node.left$}\;
		\FRecursivePostorder{$node.right$}\;
		visit(node)\;
  	}
  	\;
  	\Fn{\FIterativePostorder{$node$}}{
  			s $\leftarrow$ \textbf{empty stack}\;
  			lastNodeVisited $\leftarrow$ \textbf{null}\;
  			\While{(\normalfont{\textbf{not} s.isEmpty() \textbf{or} node $\neq$ \textbf{null}})}{
  				\If{(\normalfont{node $\neq$ \textbf{null}})}{
  					s.push(node)\;
  					node $\leftarrow$ node.left\;
  				}
    	    	\Else{
    	    		peekNode $\leftarrow$ s.peek()\;
    	    		\CommentSty{$/*$ If right child exists and traversing node from left child, then move right $/*$}\;
    	    		
    	    		\If{(\normalfont{peekNode.right $\neq$ \textbf{null} \textbf{and} lastNodeVisited $\neq$ peekNode.right})}{
    	    			node $\leftarrow$ peekNode.right\;
    	    		}
    	    		\Else{
    	    			visit(peekNode)\;
    	    			lastVisitedNode $\leftarrow$ s.pop()\;
    	    		}
    	    	}
        	}
  	}
\caption{Post-order pseudocode.}
\end{algorithm}

\begin{lstlisting}[firstnumber=1, caption={Recursive and iterative implementation of post-order traversal.}]
class BinaryTree():
	...

	def recursive_print_tree(self):
		return self.postorder_recursive_print(tree.root, "")[:-1]
	
	def iterative_print_tree(self):
		return self.postorder_search_iterative(tree.root, "")

	def postorder_search_recursive(self, start, find_val):
		if start:
			self.postorder_search_recursive(start.left, find_val)
			self.postorder_search_recursive(start.right, find_val)
			if start.value == find_val:
				return True

	def postorder_search_iterative(self, start, find_val):
		if start == None:
			return None
		stack = []
		stack.push(start)
		last_visited_node = None
		visited = []
		current = start
		while stack or current != None:
			if current != None:
				s.push(current)
				current = current.left
			else:
				# Take the last element of the stack
				peeked_node = stack[-1]
				# If right child exists and traversing node from left child, then move right
				if (peeked_node.right != null and last_visited_node != peeked_node.right):
					current = peeked_node.right
				else:
					if peeked_node.value == find_val:
						return True
					visited.append(peeked_node)
					last_visited_node = stack.pop()
		return visited

	def postorder_recursive_print(self, start, traversal):
		if start:
			traversal = self.postorder_recursive_print(start.left, traversal)
			traversal = self.postorder_recursive_print(start.right,traversal)
			traversal += (str(start.value) + "-")
		return traversal
\end{lstlisting}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/appendix/images/appendixtree/treesappendix_3.pdf}
		\caption[Post-order iterative example.]{Post-order iterative example.}
		\label{appendixtrees_3}
	\end{center}
\end{figure}

\section{Breadth-first search Implementation}
In the case of the \textbf{breadth-first search} (Chapter \ref{chp:trees}) the implementation uses a queue (Section \ref{queue}) instead of a stack. Also here the convention is to check the left node first and later the right ones. The pesudocode is adapted from the general case of the breadth-first search taken from here \cite{wikibreadthfirst} (\href{https://en.wikipedia.org/wiki/Breadth-first_search}{Breadth-first search, Wikipedia}).

\begin{algorithm}[H]
	\DontPrintSemicolon
	\LinesNumbered
  	\SetKwFunction{FBreadthFirstSearch}{Breadth-first-search}
  	\SetKwProg{Fn}{Function}{:}{}
  	\Fn{\FBreadthFirstSearch{$node$}}{
  		q $\leftarrow$ \textbf{empty queue}\;
  		visit(node)\;
  		q.enqueue(node)\;
  		\While{(\normalfont{\textbf{not} q.isEmpty()})}{
  			node $\leftarrow$ q.dequeue()\;
  			visit(node)\;
			\CommentSty{$/*$ Left child is enqueue first so that left is processed first (FIFO) $*/$}\;
			\If{\normalfont{node.left $\neq$ \textbf{null}}}{
				q.enqueue(node.left)\;							
			}
			\If{\normalfont{node.right $\neq$ \textbf{null}}}{
				q.enqueue(node.right)\;							
			}
        }
  	}
\caption{Breadth-first search pseudocode.}
\end{algorithm}

\begin{lstlisting}[firstnumber=1, caption={Breadth-first search implementation.}]
class BinaryTree():
	...

	def breadth_first_search(self, start, find_val):
		if start == None:
			return None
		visited = []
		queue = []
		queue.append(start)
		while queue:
			node = queue.pop(0)
			visited.append(node)
			if node.value == find_val:
				return True
			# Left node is added first so that the left side nodes are visited first
			if node.left:
				queue.append(node.left)
			if node.right:
				queue.append(node.right)
		return visited
\end{lstlisting}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/appendix/images/appendixtree/treesappendix_4.pdf}
		\caption[Breadth-first search example.]{Breadth-first search example.}
		\label{appendixtrees_3}
	\end{center}
\end{figure}

\section{Complexity Summary}