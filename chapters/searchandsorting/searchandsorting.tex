\chapter{Searching and Sorting}
\label{chp: searchandsorting}
In this chapter the most important and used algorithms about \textbf{searching} (retrieve some data stored in a particular data structure) \cite{wikisearch}, and \textbf{sorting} (put in a certain order some data) \cite{wikisorting} are discussed.
\section{Binary Search}
Let us consider the problem of finding a number in an array sorted in \textbf{ascending} order (Figure \ref{sorting_1}).

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, row 1/.style={nodes=draw} ] (mat1)
{
1 & 3 & 9 & 11 & 15 & 19 & 29 \\
};

\draw ($(mat1.south) + (0,-4mm)$) node[draw=none, rectangle, align=left] {$25?$};

\end{tikzpicture}
\caption[An array with numeric values ordered in ascending order.]{An array with numeric values ordered in ascending order.}
\label{sorting_1}
\end{figure}

A first way to tackle this problem might be to check all the numbers of the array. In other words, this method consists in performing a loop all over the elements of the array, and check one by one each number. The complexity of this method is \(O(n)\) since in the worst case we have to look at all the elements of the array.

A more efficient way to search an element in an array sorted in ascending order is the \textbf{binary search algorithm} \cite{wikibinarysearch}. In this algorithm the first element to be checked is the central value of the array (in case the array has an even number of elements there are two central values, and one can choose the bigger or the lower equally). If the central element is the one we are looking for the search ends, otherwise, since the array is sorted with an ascending order, we can ignore one half of the array. If the central number is bigger than the number we are looking for, we will ignore the right half of the array, instead, if the central number is lower than the number we are looking for we will ignore the left half of the array. This procedure is repeated: we consider the central value of the new subarray, which has half of the size of the previous step, and we check if that value is the one we are looking for. If not, the process is repeated until or we find or we do not find the desired element (Figure \ref{sorting_2}).

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, nodes={fill=ForestGreen!30}, row 1 column 4/.style={nodes={fill=BrickRed!30}}, nodes=draw] (array1) {
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};
\draw ($(array1-1-7.east) + (15mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=15ex] {$25>11$};

\matrix[array, row 1 column 5/.style={nodes={fill=ForestGreen!30}}, row 1 column 6/.style={nodes={fill=BrickRed!30}}, row 1 column 7/.style={nodes={fill=ForestGreen!30}}, nodes=draw] (array2) at ($(array1.south) + (0, -12mm)$){
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};
\draw ($(array2-1-7.east) + (15mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=15ex] {$25>19$};
\draw[->, >=stealth, BrickRed] (array1-1-4) -- (array2-1-4);

\matrix[array, row 1 column 7/.style={nodes={fill=BrickRed!30}}] (array3) at ($(array2.south) + (0, -12mm)$){
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};
\draw ($(array3-1-7.east) + (15mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=15ex] {$25\neq19$};
\draw[->, >=stealth, BrickRed] (array2-1-6) -- (array3-1-6);

\end{tikzpicture}

\caption[Binary search algorithm.]{Binary search algorithm.}
\label{sorting_2}
\end{figure}

\subsection{Complexity of the Binary Search Algorithm}
For evaluating the complexity of this algorithm we have to evaluate the number of steps required for solving the problem. We already know that the complexity will not be \(O(n)\), since in this algorithm not all the elements of the array are checked. Typically, the way for evaluating the complexity of an algorithm is to execute its implementation by varying the size of the input, and evaluating how many operations are done in the worst case. In the binary search algorithm the worst case is when the size of the array becomes one, so we find or we do not find the desired element in the last step.

\begin{table}[H]
\caption[Binary search complexity.]{The number of iterations grows of one every power of two of the array size, in other words it grows as \(log(n)\).}
\label{binarysearchefficiency}
\centering
\begin{tabular}{ | l | c | c | c | c | c | c | c | c | c |}
   
    \multicolumn{1}{l}{} & \multicolumn{1}{c}{} & 
    \multicolumn{1}{c}{\(2^{0}\)} & \multicolumn{1}{c}{\(2^{1}\)} &
    \multicolumn{1}{c}{} & \multicolumn{1}{c}{\(2^{2}\)} & 
    \multicolumn{1}{c}{} & \multicolumn{1}{c}{}          & 
    \multicolumn{1}{c}{} & \multicolumn{1}{c}{\(2^{3}\)} \\
    \hline
	Array Size & 0 & \cellcolor{LightCyan} 1 & \cellcolor{LightCyan} 2 & 3 & \cellcolor{LightCyan} 4  & 5 & 6 & 7 & \cellcolor{LightCyan} 8 \\
    \hline
	Iterations (worst case) & 0 & \cellcolor{LightCyan} 1 & \cellcolor{LightCyan} 2 & 2 & \cellcolor{LightCyan} 3 & 3 & 3 & 3 & \cellcolor{LightCyan} 4 \\
	\hline	
\end{tabular}
\end{table}

We observe that the exponent is the number of iterations minus one, then the logarithm base two of the array size plus one is the number of iterations:
\begin{center}
\(\#iterations\ = log_{2}(array\ size) + 1 = log_{2}(n) + 1\)
\end{center}
In general it is used \(log\), and is said that the binary search algorithm has a complexity of \(log(n)\). 

\subsection{Binary Search Implementation}
The following code is the python implementation of the binary search algorithm.
\begin{lstlisting}[firstnumber=1, caption={Binary search python implementation.}]
def binary_search(array_input, value):
	low = 0
	high = len(array_input) - 1
	while low <= high:
		mid = (low + high) // 2
		if array_input[mid] == value:
			return mid
		elif value > array_input[mid]:
			new_low = mid + 1
		else:
			new_high = mid - 1
	return -1
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none, row 2 column 1/.style={nodes={fill=ForestGreen!30}}, row 2 column 7/.style={nodes={fill=ForestGreen!30}}, row 2 column 4/.style={nodes={fill=BrickRed!30}},
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array1) {
L &   &   & M  &    &    & H  \\ 
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};

\matrix[array, fill=none, row 2 column 5/.style={nodes={fill=ForestGreen!30}}, row 2 column 6/.style={nodes={fill=BrickRed!30}}, row 2 column 7/.style={nodes={fill=ForestGreen!30}},
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array2) at ($(array1) + (0, -18mm)$){
  &   &   &    & L' & M  & H  \\
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};
\draw ($(array2-2-7.east) + (16mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=15ex] {$L'=M+1$};

\matrix[array, fill=none, row 2 column 1/.style={nodes={fill=ForestGreen!30}}, row 2 column 2/.style={nodes={fill=BrickRed!30}}, row 2 column 3/.style={nodes={fill=ForestGreen!30}},
row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array3) at ($(array2) + (0, -18mm)$){
L & M & H' &    &    &    &   \\
1 & 3 & 9 & 11 & 15 & 19 & 29 \\};
\draw ($(array3-2-7.east) + (16mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=15ex] {$H'=M-1$};

\end{tikzpicture}

\caption[Array splitting in the implementation of the binary search algorithm.]{Array splitting in the implementation of the binary search algorithm.}
\label{sorting_3}
\end{figure}

\section{Bubble Sort}
\textbf{Bubble sort} is the easiest sorting algorithm working on arrays. Bubble sort works by swapping two elements at each step if they are in the wrong order, and it repeats this process until all the array is completely ordered \cite{wikibubblesort}. In this way, the bigger elements tend to move at the bottom of the array, like bubbles that move at the top of a water bottle (Figure \ref{sorting_4}).

\subsection{Complexity of the Bubble Sort Algorithm}
For ordering an array using the bubble sort \(n - 1\) iterations are required for every step. The number of total steps are \(n - 1\), thus the total number of operations to be executed for ordering an array is \((n - 1)*(n - 1) = n^{2} - 2n + 1 = O(n^{2})\).

In summary:
\begin{itemize}
\item \textbf{Worst Case}: \(O(n^{2})\)
\item \textbf{Average Case}: \(O(n^{2})\)
\item \textbf{Best Case}: \(O(n)\). The array is already ordered and it is enough to cycle over all the elements.
\end{itemize} 

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array] (array1) {
8 & 3 & 1 & 7 & 0 \\};
\draw ($(array1.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west] {Start};

\matrix[array, row 1 column 1/.style={nodes={fill=BrickRed!30}}] (array2) at ($(array1) + (0,-12mm)$) {
8 & 3 & 1 & 7 & 0 \\};
\draw ($(array2.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 1};
\draw ($(array2.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array2-1-1.north) edge [bend left=40] (array2-1-2.north);

\matrix[array, row 1 column 2/.style={nodes={fill=BrickRed!30}}] (array3) at ($(array2) + (0,-12mm)$) {
3 & 8 & 1 & 7 & 0 \\};
\draw ($(array3.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 2};
\draw ($(array3.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array3-1-2.north) edge [bend left=40] (array3-1-3.north);

\matrix[array, row 1 column 3/.style={nodes={fill=BrickRed!30}}] (array4) at ($(array3) + (0,-12mm)$) {
3 & 1 & 8 & 7 & 0 \\};
\draw ($(array4.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 3};
\draw ($(array4.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array4-1-3.north) edge [bend left=40] (array4-1-4.north);

\matrix[array, row 1 column 4/.style={nodes={fill=BrickRed!30}}] (array5) at ($(array4) + (0,-12mm)$) {
3 & 1 & 7 & 8 & 0 \\};
\draw ($(array5.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 4};
\draw ($(array5.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array5-1-4.north) edge [bend left=40] (array5-1-5.north);

\matrix[array, row 1 column 1/.style={nodes={fill=BrickRed!30}}, row 1 column 5/.style={nodes={fill=ForestGreen!30}}] (array6) at ($(array5) + (0,-12mm)$) {
3 & 1 & 7 & 0 & 8 \\};
\draw ($(array6.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 5};
\draw ($(array6.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array6-1-1.north) edge [bend left=40] (array6-1-2.north);

\matrix[array, row 1 column 2/.style={nodes={fill=BrickRed!30}}] (array7) at ($(array6) + (0,-12mm)$) {
1 & 3 & 7 & 0 & 8 \\};
\draw ($(array7.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 6};
\draw ($(array7.east) + (21.4mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=10ex] {Compare: \\ no swap};
\path[<->, >=stealth, BrickRed] (array7-1-2.north) edge [bend left=40] (array7-1-3.north);

\matrix[array, row 1 column 3/.style={nodes={fill=BrickRed!30}}] (array8) at ($(array7) + (0,-12mm)$) {
1 & 3 & 7 & 0 & 8 \\};
\draw ($(array8.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 7};
\draw ($(array8.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array8-1-3.north) edge [bend left=40] (array8-1-4.north);

\matrix[array, row 1 column 4/.style={nodes={fill=BrickRed!30}}] (array9) at ($(array8) + (0,-12mm)$) {
1 & 3 & 0 & 7 & 8 \\};
\draw ($(array9.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 8};
\draw ($(array9.east) + (21.4mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=10ex] {Compare: \\ no swap};
\path[<->, >=stealth, BrickRed] (array9-1-4.north) edge [bend left=40] (array9-1-5.north);

\matrix[array, row 1 column 1/.style={nodes={fill=BrickRed!30}}, row 1 column 4/.style={nodes={fill=ForestGreen!30}}] (array10) at ($(array9) + (0,-12mm)$) {
1 & 3 & 0 & 7 & 8 \\};
\draw ($(array10.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=6ex] {Step 9};
\draw ($(array10.east) + (21.4mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=10ex] {Compare: \\ no swap};
\path[<->, >=stealth, BrickRed] (array10-1-1.north) edge [bend left=40] (array10-1-2.north);

\matrix[array, row 1 column 2/.style={nodes={fill=BrickRed!30}}] (array11) at ($(array10) + (0,-12mm)$) {
1 & 3 & 0 & 7 & 8 \\};
\draw ($(array11.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=10ex] {Step 10};
\draw ($(array11.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array11-1-2.north) edge [bend left=40] (array11-1-3.north);

\matrix[array, row 1 column 3/.style={nodes={fill=BrickRed!30}}] (array12) at ($(array11) + (0,-12mm)$) {
1 & 0 & 3 & 7 & 8 \\};
\draw ($(array12.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=10ex] {Step 11};
\draw ($(array12.east) + (21.4mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=10ex] {Compare: \\ no swap};
\path[<->, >=stealth, BrickRed] (array12-1-3.north) edge [bend left=40] (array12-1-4.north);

\matrix[array, row 1 column 1/.style={nodes={fill=BrickRed!30}}, row 1 column 3/.style={nodes={fill=ForestGreen!30}}] (array13) at ($(array12) + (0,-12mm)$) {
1 & 0 & 3 & 7 & 8 \\};
\draw ($(array13.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=10ex] {Step 12};
\draw ($(array13.east) + (15mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east, text width=6ex] {Compare: \\ swap};
\path[<->, >=stealth, BrickRed] (array13-1-1.north) edge [bend left=40] (array13-1-2.north);

\matrix[array] (array14) at ($(array13) + (0,-12mm)$) {
0 & 1 & 3 & 7 & 8 \\};
\draw ($(array14.west) + (-14mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, anchor=west, text width=10ex] {Step 13};
\draw ($(array14.east) + (10mm,0)$) node[draw=none, rectangle, align=center, minimum size=7mm, anchor=east] {Sorted};

\end{tikzpicture}

\caption[The swapping process is repeated until the array is completely ordered.]{The swapping process is repeated until the array is completely ordered.}
\label{sorting_4}
\end{figure}

\subsection{Bubble Sort Implementation}
The following code is the python implementation of the bubble sort algorithm.
\begin{lstlisting}[firstnumber=1, caption={Bubble Sort python implementation}.]
def bubble_sort(array_input):
	index = len(array_input) - 1
	sorted = False
	
	while not sorted:
		sorted = True
		for i in range(0, index):
			if array_input[i] > array_input[i + 1]:
				sorted = False
				array_input[i], array_input[i + 1] = array_input[i + 1], array_input[i]
	return array_input
\end{lstlisting}

\section{Merge Sort}
The \textbf{merge sort} algorithm works by dividing the array in single elements at first, and, grouping and ordering all the elements two by two. After the first step we will have a lot of subarrays of two elements. The next step is to merge all these subarrays and to order the elements. The merging and ordering process is repeated until the array is unified again \cite{wikimergesort}. This way of reducing a big problem in several smaller problems is called \textbf{Divide et impera} (Divide and conquer).

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array] (array11) {
8 & 3 & 1 & 7 & 0 & 10 & 2 \\};

\matrix[array] (array21) at ($(array11) + (-25mm, -14mm)$) {
8 & 3 & 1 & 7 \\};
\matrix[array] (array22) at ($(array11) + (25mm, -14mm)$){
0 & 10 & 2 \\};
\draw[->, >=stealth] (array11.south) -- (array21.north);
\draw[->, >=stealth] (array11.south) -- (array22.north);

\matrix[array] (array31) at ($(array21) + (-10mm, -14mm)$) {
8 & 3 \\};
\matrix[array] (array32) at ($(array21) + (10mm, -14mm)$){
1 & 7 \\};
\draw[->, >=stealth] (array21.south) -- (array31.north);
\draw[->, >=stealth] (array21.south) -- (array32.north);
\matrix[array] (array33) at ($(array22) + (-10mm, -14mm)$){
0 & 10 \\};
\matrix[array] (array34) at ($(array22) + (10mm, -14mm)$){
2 \\};
\draw[->, >=stealth] (array22.south) -- (array33.north);
\draw[->, >=stealth] (array22.south) -- (array34.north);

\matrix[array] (array41) at ($(array31) + (-5mm, -14mm)$) {
8 \\};
\matrix[array] (array42) at ($(array31) + (5mm, -14mm)$) {
3 \\};
\path[<->, >=stealth, BrickRed] ($(array41.south) + (0, 1.4mm)$) edge [bend right=40] ($(array42.south) + (0, 1.4mm)$);
\draw[->, >=stealth] (array31.south) -- (array41.north);
\draw[->, >=stealth] (array31.south) -- (array42.north);
\matrix[array] (array43) at ($(array32) + (-5mm, -14mm)$) {
1 \\};
\matrix[array] (array44) at ($(array32) + (5mm, -14mm)$) {
7 \\};
\draw[->, >=stealth] (array32.south) -- (array43.north);
\draw[->, >=stealth] (array32.south) -- (array44.north);
\matrix[array] (array45) at ($(array33) + (-5mm, -14mm)$) {
0 \\};
\matrix[array] (array46) at ($(array33) + (5mm, -14mm)$) {
10 \\};
\draw[->, >=stealth] (array33.south) -- (array45.north);
\draw[->, >=stealth] (array33.south) -- (array46.north);
\matrix[array] (array47) at ($(array34) + (0, -14mm)$) {
2 \\};
\draw[->, >=stealth] (array34.south) -- (array47.north);

\matrix[array] (array51) at ($(array31) + (0, -28mm)$) {
3 & 8 \\};
\matrix[array] (array52) at ($(array32) + (0, -28mm)$){
1 & 7 \\};
\path[->, >=stealth, BrickRed] ($(array51-1-1.south) + (0, 0)$) edge [bend right=40] ($(array52-1-1.south) + (0, 0)$);
\path[->, >=stealth, BrickRed] ($(array51-1-1.south) + (0, 0)$) edge [bend right=40] ($(array52-1-2.south) + (0, 0)$);
\path[->, >=stealth, BrickRed] ($(array51-1-2.north) + (0, 0)$) edge [bend left=40] ($(array52-1-1.north) + (0, 0)$);
\path[->, >=stealth, BrickRed] ($(array51-1-2.north) + (0, 0)$) edge [bend left=40] ($(array52-1-2.north) + (0, 0)$);
\draw[->, >=stealth] (array41.south) -- (array51.north);
\draw[->, >=stealth] (array42.south) -- (array51.north);
\draw[->, >=stealth] (array43.south) -- (array52.north);
\draw[->, >=stealth] (array44.south) -- (array52.north);
\matrix[array] (array53) at ($(array33) + (0, -28mm)$){
0 & 10 \\};
\matrix[array] (array54) at ($(array34) + (0, -28mm)$){
2 \\};
\draw[->, >=stealth] (array45.south) -- (array53.north);
\draw[->, >=stealth] (array46.south) -- (array53.north);
\draw[->, >=stealth] (array47.south) -- (array54.north);

\matrix[array] (array61) at ($(array21) + (0, -56mm)$) {
1 & 3 & 7 & 8 \\};
\matrix[array] (array62) at ($(array22) + (0, -56mm)$){
0 & 2 & 10 \\};
\draw[->, >=stealth] (array51.south) -- (array61.north);
\draw[->, >=stealth] (array52.south) -- (array61.north);
\draw[->, >=stealth] (array53.south) -- (array62.north);
\draw[->, >=stealth] (array54.south) -- (array62.north);

\matrix[array] (array71) at ($(array11) + (0, -84mm)$){
0 & 1 & 2 & 3 & 7 & 8 & 10 \\};
\draw[->, >=stealth] (array61.south) -- (array71.north);
\draw[->, >=stealth] (array62.south) -- (array71.north);

\end{tikzpicture}

\caption[Merge sort algorithm.]{In merge sort algorithm the merging and sorting process is repeated until the array is again unified with all the elements sorted.}
\label{sorting_6}
\end{figure}

The steps are (Figure \ref{sorting_6}): 
\begin{itemize}
\item[1] Divide the array in subarryas of one element. Merge two by two and order the elements. The number of the subarrays is odd, so one array at this step is not merged. \textbf{The number of comparisons for this step is 3}.
\item[2] Merge and order again the new subarrays. For ordering in this case we start from the first element of the array on the left, and we compare this value with all the elements of the array on the right. If the first element is bigger than the picked one from the array on the right is moved, otherwise is not moved and we go to the next element. \textbf{The number of comparisons for this step is 5.}   
\item[3] Merge and order again as in the previous step. \textbf{The number of comparisons for this step is 6.}
\end{itemize}

\subsection{Complexity of the Merge Sort Algorithm}
For evaluating the complexity of this algorithm we have to count the number of iterations and comparisons done. By using the example showed in Figure \ref{sorting_6} we will try to extrapolate a general pattern for an array of dimension \(n\).

The number of comparisons depends by the size of the array. For an array of two elements the number of comparisons is one, for one of three elements are two, for one of four are three, and for one of seven are six. It is impossible to calculate in general the number of comparisons, but it is possible to calculate the worst case given the array dimension. From the previous example we see that for each step the maximum number of comparisons is seven, the size of the array. The reason is that the sum of all subarrays is seven. In general the sum of all subarrays is always the size of the array. Thus, the total complexity is \(O(\# \ of\ comparison \ * \ \# \ of \ iterations \ )\).

How many iterations are required? In our example for an array of seven elements the iterations required are three. While from the subprocess we observe that for an array of size four the number of iterations are two, for one of size three are two, and for one of size two is one. Thus, we can create the following table:

\begin{table}[H]
\caption[Merge Sort Complexity.]{The number of iterations grows of one every power of two, in others words it grows as \(log(n)\).}
\label{mergesortefficiency}
\centering
\begin{tabular}{ | l | c | c | c | c | c | c | c | c | c |}
   
    \multicolumn{1}{l}{} & \multicolumn{1}{c}{\(2^{0}\)} & 
    \multicolumn{1}{c}{\(2^{1}\)} & \multicolumn{1}{c}{} &
    \multicolumn{1}{c}{\(2^{2}\)} & \multicolumn{1}{c}{} & 
    \multicolumn{1}{c}{} & \multicolumn{1}{c}{}          & 
    \multicolumn{1}{c}{\(2^{3}\)} & \multicolumn{1}{c}{} \\
    \hline
	Array Size & \cellcolor{LightCyan} 1 & \cellcolor{LightCyan} 2 & 3 & \cellcolor{LightCyan} 4 & 5  & 6 & 7 & \cellcolor{LightCyan} 8 & 9 \\
    \hline
	Iterations (worst case) & \cellcolor{LightCyan} 0 & \cellcolor{LightCyan} 1 & 2 & \cellcolor{LightCyan} 2 & 3 & 3 & 3 & \cellcolor{LightCyan} 3 & 4 \\
	\hline	
\end{tabular}
\end{table}

By considering also the number of comparisons, the complexity is \(O(n \ log(n))\), which is better than \(O(n^{2})\) of the bubble sort. 

The memory complexity in this case is bigger than the bubble sort algorithm. For the merge sort some subarrays (in the worst case are \(n\)) are used, and they need to be stored in the memory.

\subsection{Merge Sort Implementation}
The following code is the python implementation of the merge sort algorithm.
\begin{lstlisting}[firstnumber=1, caption={Merge Sort python implementation (the recursive part is taken from \href{https://www.geeksforgeeks.org/iterative-merge-sort/}{Merge Sort, GeeksforGeeks}).}]
def merge_sort_iterative(array_input):
	
	if len(array_input) > 1:
		mid = len(array_input)//2
		left_side = array_input[:mid]
		right_side = array_input[mid:]
		
		merge_sort(left_side)
		merge_sort(right_side)
		
		i = 0 # Left side index
		j = 0 # Right side index
		k = 0 # Sorted array index
		
		while i < len(left_side) and j < len(right_side):
			if left_side[i] < right_side[j]:
				array_input[k] = left_side[i]
				i+= 1
			else:
				array_input[k] = right_side[j]
				j+= 1
			k+= 1
			
		# Adding all elements if some of 
        # them have been left behind 
        while i < len(left_side): 
        	array_input[k] = left_side[i] 
            i+= 1
            k+= 1
            
        while j < len(right_side): 
        	array_input[k] = right_side[j] 
            j+= 1
            k+= 1
			
	return array_input
	
# Recursive implementation
def merge(left, right):
    if not len(left) or not len(right):
        return left or right
 
    result = []
    i, j = 0, 0
    while (len(result) < len(left) + len(right)):
        if left[i] < right[j]:
            result.append(left[i])
            i+= 1
        else:
            result.append(right[j])
            j+= 1
        if i == len(left) or j == len(right):
            result.extend(left[i:] or right[j:])
            break
 
    return result
 
def mergesort(list):
    if len(list) < 2:
        return list
 
    middle = len(list)/2
    left = mergesort(list[:middle])
    right = mergesort(list[middle:])
 
    return merge(left, right)
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none, row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}, row 2 column 4/.style={nodes={fill=ForestGreen!30}}, row 2 column 5/.style={nodes={fill=BrickRed!30}}] (array1) {
L &   &   & M  & M' &    & H \\ 
  &   &   &    &    &    &   \\};
  
\draw ($(array1-2-7.east) + (12mm,0)$) node[draw=none, rectangle, align=left, minimum size=7mm, text width=12ex] {$M'=M+1$};

\draw[decorate, decoration={brace, amplitude=3pt, mirror}] 
    ($(array1-2-1.west) + (0, -5mm)$) coordinate (array1-2-1.west) -- ($(array1-2-4.east) + (0, -5mm)$) coordinate (array1-2-4.east);
\draw[decorate, decoration={brace, amplitude=3pt, mirror}] 
    ($(array1-2-5.west) + (0, -5mm)$) coordinate (array1-2-1.west) -- ($(array1-2-7.east) + (0, -5mm)$) coordinate (array1-2-4.east);
\draw ($(array1-2-4.south) + (-12mm,-3mm)$) node[draw=none, rectangle, align=left, minimum size=7mm] (left) {left};
\draw ($(array1-2-4.south) + (15mm,-3.5mm)$) node[draw=none, rectangle, align=left, minimum size=7mm] (right) {right};

\matrix[array, fill=none, row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array21) at ($(array1-2-4.south) + (-18mm,-14mm)$) {
L &   &   & M  \\ 
  & i &   &    \\};
  
\matrix[array, fill=none, row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array22) at ($(array1-2-4.south) + (18mm,-14mm)$) {
M' &   & H  \\ 
   & j &    \\};

\draw[->,  >=stealth] (left.south) -- (array21-2-2.north east);
\draw[->,  >=stealth] (right.south) -- (array22-2-2.north);

\draw ($(array21-2-2.south east) + (0,-2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (comp11) {left[i]};
\draw ($(array22-2-2.south) + (-1mm,-2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (comp12) {right[j]};

\draw ($(array1-2-4.south) + (-7mm,-34mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (comp1) {left[i]<right[j]};

\draw ($(array1-2-4.south) + (-7mm,-47mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (comp21) {left[i]};
\draw ($(array1-2-4.south) + (7mm,-47mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (comp22) {right[j]};

\draw[->,  >=stealth] (comp11.south) -- ($(comp1.north) + (7mm,-2mm)$);
\draw[->,  >=stealth] (comp12.south) -- ($(comp1.north) + (7mm,-2mm)$);

\draw[->,  >=stealth, ForestGreen] ($(comp1.south) + (7mm,2mm)$) -- ($(comp21.north) + (0,-2mm)$);
\draw[->,  >=stealth, BrickRed] ($(comp1.south) + (7mm,2mm)$) -- ($(comp22.north) + (0,-2mm)$);
\draw ($(array1-2-4.south) + (-9mm,-40mm)$) node[draw=none, rectangle, align=center, minimum size=7mm, ForestGreen] {yes};
\draw ($(array1-2-4.south) + (9mm,-40mm)$) node[draw=none, rectangle, align=center, minimum size=7mm, BrickRed] {no};

\matrix[array, fill=none, row 1/.style={nodes={draw=none, fill=none, minimum size=5mm}}] (array1) at ($(array1-2-4.south) + (0,-50mm)$) {
L &   &   &   &   &   & H \\
  &   &   & k &   &   &   \\};

\end{tikzpicture}

\caption[Merge sort algorithm implementation.]{Merge sort algorithm implementation.}
\label{sorting_7}
\end{figure}

\section{Quicksort}
The \textbf{quicksort} is a sorting algorithm of the divide et impera class. It works by randomly choosing an element of the array, called pivot, and putting all the bigger and lower values on its left and on its right respectively. This procedure is repeated recursively on the two new subarrays until all the elements have been a pivot \cite{wikiqicksort}. 

Here are the steps of the quicksort algorithm based on the example of Figure \ref{sorting_8}:
\begin{itemize}
\item[1] Let us consider the last element as pivot, \(2\) in this case, and let us compare it with all the elements on its left. Let us start from the first element of the array, and let us compare their values. In this case \(8 > 2\), so \(8\) is moved on the position of the pivot (\(2\)) which is moved of one position to the left. The number to be removed, \(10\) in this case, is moved in the first position.
\item[2] Let us repeat the process. Now we have to compare the pivot (\(2\)) in the new position with the first element (\(10\)), and because \(10>2\) we repeat the previous step of moving the elements.
\item[3] In this case \(0<2\) so we do not have to do anything, and then we move to the next element, \(3\) in this case.
\item[4] For the pivot \(2\) all the elements on the left are less than it, and all the elements on the right are bigger than it. \(2\) is not moved anymore. At this point we can change the pivot and repeat all the steps for the new pivots until all the elements have been a pivot.
\end{itemize}

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none, row 1 column 7/.style={nodes={fill=BrickRed!30}}] (array1) { 
8 & 3 & 1 & 7 & 0 & 10 & 2 \\};

\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array12) at ($(array1.south) + (0,-14mm)$) {
2 \\};
\draw ($(array12.north) + (-2mm,2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (pivot1) {pivot};
\matrix[array, fill=none, row 1 column 2/.style={nodes={fill=BrickRed!30}}] (array11) at ($(array1.south) + (-18mm,-14mm)$) {
1 & 0 \\};
\matrix[array, fill=none, row 1 column 4/.style={nodes={fill=BrickRed!30}}] (array13) at ($(array1.south) + (26mm,-14mm)$) {
8 & 3 & 7 & 10 \\};
\draw[->,  >=stealth] (array1.south) -- (array11.north);
\draw[->,  >=stealth] (array1.south) -- (array13.north);

\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array21) at ($(array11.south) + (-5mm,-14mm)$) {
0 \\};
\draw ($(array21.north) + (-2mm,2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (pivot21) {pivot};
\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array22) at ($(array11.south) + (5mm,-14mm)$) {
1 \\};
\draw[->,  >=stealth] (array11.south) -- (array22.north);

\matrix[array, fill=none, row 1 column 3/.style={nodes={fill=BrickRed!30}}] (array23) at ($(array13.south) + (-10mm,-14mm)$) {
8 & 3 & 7 \\};
\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array24) at ($(array13.south) + (10mm,-14mm)$) {
10 \\};
\draw ($(array24.north) + (-2mm,2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (pivot24) {pivot};
\draw[->,  >=stealth] (array13.south) -- (array23.north);

\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array31) at ($(array23.south) + (-10mm,-14mm)$) {
3 \\};
\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array32) at ($(array23.south) + (0,-14mm)$) {
7 \\};
\draw ($(array32.north) + (-2mm,2mm)$) node[draw=none, rectangle, align=center, minimum size=7mm] (pivot32) {pivot};
\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=ForestGreen!30}}] (array33) at ($(array23.south) + (10mm,-14mm)$) {
8 \\};
\draw[->,  >=stealth] (array23.south) -- (array31.north);
\draw[->,  >=stealth] (array23.south) -- (array33.north);

\matrix[array, fill=none, row 1/.style={nodes={fill=ForestGreen!30}}] (array4) at ($(array1.south) + (0,-70mm)$) { 
0 & 1 & 2 & 3 & 7 & 8 & 10\\};

\end{tikzpicture}

\caption[Quicksort algorithm.]{Quicksort algorithm.}
\label{sorting_8}
\end{figure}

\subsection{Complexity of the Quicksort Algorithm}
Evaluating the complexity of quicksort is very hard. In the following there are some justifications for the worst, the best, and the average case complexity.

Let us consider first the worst case complexity. In this situation the last elements of the array are the bigger ones, so it is necessary to check all the previous elements, by doing \(n^{2}\) comparisons Figure \ref{sorting_10}.

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none, row 1 column 6/.style={nodes={fill=BrickRed!30}}, row 1 column 7/.style={nodes={fill=BrickRed!30}},
row 2/.style={nodes={font=\tiny, draw=none, fill=none, minimum size=5mm}},
row 3/.style={nodes={font=\tiny, draw=none, fill=none, minimum size=5mm}}] (array1) { 
1 & 8 & 2 & 5 & 3 & 9 & 13 \\
1<13 & 8<13 & 2<13 & 5<13 & 3<13 & 9<13 \\
1<9 & 8<9 & 2<9 & 5<9 & 3<9 \\};

\end{tikzpicture}

\caption[Quicksort algorithm worst case.]{Quicksort algorithm worst case.}
\label{sorting_10}
\end{figure}

In the best and in the average case the complexity is \(O(n log(n))\). The reason is because the first pivot tends to move at the center of the array, obtaining in this way two subarrays. In turn the pivots of these two subarrays will tend to move at their center (Figue \ref{sorting_11}), and the process is repeated until all the elements have been a pivot, and eventually obtaining an ordered array.

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none] (array1) { 
\checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \color{BrickRed}{\checkmark} & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\};

\path[->, >=stealth, BrickRed] (array1-1-11.north) edge [bend right=50] (array1-1-10.north);
\path[->, >=stealth, BrickRed] (array1-1-9.north) edge [bend right=50] (array1-1-8.north);
\path[->, >=stealth, BrickRed] (array1-1-7.north) edge [bend right=50] (array1-1-6.north);

\path[->, >=stealth] (array1-1-11.south) edge [bend left=50] (array1-1-10.south);
\path[->, >=stealth] (array1-1-9.south) edge [bend left=50] (array1-1-8.south);

\path[->, >=stealth] (array1-1-4.south) edge [bend left=50] (array1-1-3.south);
\path[->, >=stealth] (array1-1-2.south) edge [bend left=50] (array1-1-1.south);

\end{tikzpicture}

\caption[Quicksort algorithm best and average case.]{Quicksort algorithm best and average case.}
\label{sorting_11}
\end{figure}

The space complexity of quicksort is constant, \(O(1)\).

This algorithm can be optimized in several ways. For example it is possible to order at the same time two half of the array, or consider as pivot always the last elements.

\subsubsection{Quicksort and Merge Sort Comparison}
Quicksort is often a better solution than merge sort, because even if its worst case complexity is \(O(n^{2})\), this problem can be solved by using the randomized quicksort. If the right pivot is chosen the problem related to having a worst case performance is solved. Moreover, the quicksort algorithm dose not require any auxiliary memory, which is a big advance in a lot of situations.

On the other hand, merge sort is a better solution than quicksort and heapsort \cite{wikiheapsort} when the sorting is done on linked lists that do not require big auxiliary space, and on very large data sets stored on slow-to-access media, such as disk storage or network-attached storage \cite{wikiqicksort}.

\textbf{In summary}:
\begin{itemize}
\item \textbf{Worst Case}: \(O(n^{2})\)
\item \textbf{Average Case}: \(O(n\ log(n))\)
\item \textbf{Best Case}: \(O(n\ log(n))\)
\item \textbf{Space}: \(O(1)\)
\end{itemize}

\subsection{Quicksort Implementation}
The following code is the python implementation of the quicksort algorithm \cite{quicksortcode}.
\begin{lstlisting}[firstnumber=1, caption={Quicksort python implementation.}]
def partition(arr, low, high): 
    i = (low-1)         # Index of smaller element 
    pivot = arr[high]     # pivot 
  
    for j in range(low, high): 
  
        # If current element is smaller than or 
        # equal to pivot 
        if arr[j] <= pivot: 
  
            # Increment index of smaller element 
            i = i+1
            arr[i], arr[j] = arr[j], arr[i] 
  
    arr[i+1], arr[high] = arr[high], arr[i+1] 
    return (i+1) 
    
# Function to do Quick sort   
def quick_sort(arr, low, high): 
    if len(arr) == 1: 
        return arr 
    if low < high: 
  
        # pi is partitioning index, arr[p] is now 
        # at right place 
        pi = partition(arr, low, high) 
  
        # Separately sort elements before 
        # partition and after partition 
        quick_sort(arr, low, pi-1) 
        quick_sort(arr, pi+1, high)
    
\end{lstlisting}

\begin{figure}[H]
\centering
\begin{tikzpicture}[array/.style={matrix of math nodes,nodes={draw, minimum size=7mm},column sep=-\pgflinewidth, row sep=0.5mm, nodes in empty cells}, thick, text height=2.5ex, text depth=0.75ex, text width=3.25ex, align=center, column sep=-\pgflinewidth]

\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=RoyalPurple!30}}, row 1 column 3/.style={nodes={fill=BrickRed!30}}, row 1 column 8/.style={nodes={fill=ForestGreen!30}}] (array1) {
 & & & & & & & & \\};

\draw[decorate, decoration={brace, amplitude=3pt, mirror}] 
    ($(array1-1-3.south west) + (0, -1mm)$) coordinate (array1-1-1.west) -- ($(array1-1-8.south east) + (0, -1mm)$) coordinate (array1-1-8.east);


\draw ($(array1-1-5.north) + (10mm,10mm)$) node[draw=none, rectangle, align=left, minimum size=30mm, text width=30ex] (for) {for i in range($0$, elements)};
\draw ($(array1-1-8.north) + (3mm,3mm)$) node[draw=none, rectangle, align=left, minimum size=7mm, ForestGreen] (i) {i};
\draw ($(array1-1-3.north) + (10mm,3mm)$) node[draw=none, rectangle, align=left, minimum size=30mm, BrickRed, text width=20ex] (current) {current position};
\draw ($(array1-1-1.north) + (0,3mm)$) node[draw=none, rectangle, align=left, minimum size=7mm, RoyalPurple] (pivot) {pivot};
\draw ($(array1-1-5.south) + (8mm,-4mm)$) node[draw=none, rectangle, align=center, minimum size=30mm, text width=60ex] (swap1) {if array\textunderscore input$[i]$ <= array\textunderscore input$[0]$ \\
SWAP(array\textunderscore input$[i]$, array\textunderscore input$[current\textunderscore position]$)};

\matrix[array, fill=none, row 1 column 1/.style={nodes={fill=RoyalPurple!30}}, row 1 column 8/.style={nodes={fill=BrickRed!30}}] (array2) at ($(array1) + (0,-40mm)$) {
 & & & & & & & & \\};

\draw[decorate, decoration={brace, amplitude=3pt, mirror}] 
    ($(array2-1-1.south west) + (0, -1mm)$) coordinate (array2-1-1.west) -- ($(array2-1-8.south east) + (0, -1mm)$) coordinate (array2-1-8.east);


\draw ($(array2-1-5.north) + (15mm,10mm)$) node[draw=none, rectangle, align=left, minimum size=30mm, text width=50ex] (for) {At the end of the loop move the pivot};
\draw ($(array2-1-8.north) + (0,3mm)$) node[draw=none, rectangle, align=left, minimum size=7mm, BrickRed, text width=20ex] (i) {current position};
\draw ($(array2-1-1.north) + (0,3mm)$) node[draw=none, rectangle, align=left, minimum size=7mm, RoyalPurple] (pivot) {pivot};
\draw ($(array2-1-5.south) + (8mm,-5mm)$) node[draw=none, rectangle, align=center, minimum size=30mm, text width=60ex] (swap1) {
SWAP(array\textunderscore input$[0]$, array\textunderscore input$[current\textunderscore position]$)};

\end{tikzpicture}

\caption[Quicksort algorithm implementation.]{Quicksort algorithm implementation.}
\label{sorting_12}
\end{figure}