\chapter{Trees}
\label{chp: trees}
In this chapter are introduced the fundamentals concepts of tree as abstract data type, and the most used algorithms related to trees \cite{wikitrees} (\href{https://en.wikipedia.org/wiki/Tree_(data_structure)}{Trees, Wikipedia}).

\section{General Definitions}
A \textbf{tree} is an abstract datatype that simulate a hierarchical structure. A tree is a particular kind of a linked list where there are more next elements. The base element of a tree is called \textbf{node} while the first element is called \textbf{root}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_1.pdf}
		\caption[Elements of a tree and linked list.]{Elements of a tree and linked list.}
		\label{trees_1}
	\end{center}
\end{figure}

Trees must be completed connected structures, this means that there are not any nodes which are not connected to anything (Figure \ref{trees_2} case (a)), and there must not be present any cycles (Figure \ref{trees_2} case (c)).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_2.pdf}
		\caption[Possible structures of a tree.]{Completed connected structure (a), a non completed connected structure (b), and a cycle (c).}
		\label{trees_2}
	\end{center}
\end{figure}

Trees are a hierarchical structures divided into layers: the first layer is the one belonging to the root node, the first node of a tree. The next element of the root are called children, which became parents in case they have next node connected as well. The last nodes of a trees are the nodes which do not have any children and they are called \textbf{leaf}. The numbers of connections is called \textbf{height}. A set of connections creates a \textbf{path}. The numbers of edges starting from the root to a node is called \textbf{depth}.
All this definitions are defined in following figure (Figure \ref{trees_3}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_3.pdf}
		\caption[A tree and its fundamentals elements.]{A tree and its fundamentals elements.}
		\label{trees_3}
	\end{center}
\end{figure}

\section{Tree Traversal}
Which way is the most efficient for visiting all the nodes of a tree? Is it more efficient looking layer by layer or looking at subtrees? There are two different approach to traverse a tree: the \textbf{depth-first search} (\textbf{DFS}) and the \textbf{breath-first search} (\textbf{BFS}). In the first one the priority is to look at the children of a node, instead in the second one the priority is to look at the node of the same layer \ref{trees_4}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_4.pdf}
		\caption[The depth-first search and the breath-first search.]{The depth-first search and the breath-first search.}
		\label{trees_4}
	\end{center}
\end{figure}

\subsection{Depth-first search}
In the depth-first search there are several different ways to perform a search on a tree.
\paragraph{Pre-order search}
\label{preorder}
In the \textbf{pre-order search} the first node to be checked as visited is the root. The following node is the left child by convention. Once checked the left child the process is repeated until the first node without any children is reached. At that point the same process is applied to the right side: all the nodes on the right are checked until all the nodes are checked as visited \ref{trees_5}.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_5.pdf}
		\caption[Pre-order search.]{Pre-order search.}
		\label{trees_5}
	\end{center}
\end{figure}

\paragraph{In-order search}
\label{inorder}
In the \textbf{in-order search} the first node to be checked is the first node without children on the left side. Once checked off this node the next one to be checked off is its parent, and the process is repeated again on the right side of the nodes, until all the nodes are checked off.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_6.pdf}
		\caption[In-order search.]{In-order search.}
		\label{trees_6}
	\end{center}
\end{figure}

\paragraph{Post-order search}
\label{postorder}
In the \textbf{post-order search} the first node to be checked off is the first node without children on the left side. Once checked off this node the next one to be checked off is the one which does not have any children. Once all the nodes of the current left subtree without any children are checked off, the parents can be checked off, and the whole process is repeated until all the nodes are checked off.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_7.pdf}
		\caption[Post-order search.]{Post-order search.}
		\label{trees_7}
	\end{center}
\end{figure}

\section{Binary Trees}
\textbf{Binary trees} are trees in which the parent has at most two children (0, 1, 2 are the only number of admitted children). On binary trees some operations like searching, deleting, and inserting can be easily and efficiently done. 
\subsection{Search}
To search an element in the tree one of the previous methods can be used. Because in a general tree there is no ordering this means that potentially all the elements of the tree can be visited, then the complexity results in \(O(n)\).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_12.pdf}
		\caption[Example of tree search and traversal.]{Example of tree search and traversal.}
		\label{trees_12}
	\end{center}
\end{figure}

\subsection{Delete}
Before the delete process there is always a search one for finding the element to be deleted. If the element to be deleted is a leaf, deleting it is not a problem because there are not any children to be moved. Instead if the node to be removed has some children there are several opportunities to reorganize the nodes, because the condition for a binary tree must remain valid (a node can have at most two nodes). So there are several strategies. Let us consider the following tree \ref{trees_9}. 
\begin{itemize}
\item If the node to be removed has only one child it can be replaced by the child node (case 1 Figure \ref{trees_9}).
\item If the node to be removed has two children it can be replaced with the child node which has no children node (case 2 Figure \ref{trees_9}).
\item If the node to be removed has two children which have again children as well, in this case there are several options which can be done. For example on child node can be moved to the position of the one to be removed (case 3 Figure \ref{trees_9}).
\end{itemize} 

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_9.pdf}
		\caption[Delete an element of a tree.]{Delete an element of a tree.}
		\label{trees_9}
	\end{center}
\end{figure}
AGGIUNGERE IL LIBRO DI ALGORITMI CITANDO CHE SIA UNA LETTURA APPROFONDITA PER MAGGIORI DETTAGLI.
\subsection{Insert}
Insert a new element to a binary tree is not a hard operation, because it is enough to find a node which can take a new children node. In the worst case to find the proper node in which a child can be add the farthest leaf must be reached (case 1 \ref{trees_10}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_10.pdf}
		\caption[Add an element of a tree.]{Add an element of a tree.}
		\label{trees_10}
	\end{center}
\end{figure}
AGGIUNGERE IL LIBRO DI ALGORITMI CITANDO CHE SIA UNA LETTURA APPROFONDITA PER MAGGIORI DETTAGLI.
\subsection{Perfect binary tree}
A perfect binary tree is a binary tree in which all the nodes have two children except the leaf which do not have any children. In this case the following results are valid

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_11.pdf}
		\caption[Perfect binary tree results.]{Perfect binary tree results.}
		\label{trees_11}
	\end{center}
\end{figure}

When a new row is added, the number of nodes double. Given a level \(n\) the total number of nodes is \(2n + 1\).

\subsection{Binary Tree Implementation}
The following code is the recursive Python implementation of the pre-order search and traversal (Figure \ref{trees_5}). The recursive and iterative implementations of the other ways of search and traverse a tree are in appendix \ref{binappendix}.

\begin{lstlisting}[firstnumber=1, caption={Class definition for a node and a tree.}]
class Node():

	def __int__(self, value):
		self.value = value
		self.left = None
		self.right = None

class BinaryTree():

	def __init__(self, root):
		self.root = Node(root)
\end{lstlisting}

\begin{lstlisting}[firstnumber=1, caption={Recursive pre-order traversal and search implementation.}]
class Node():
	...

class BinaryTree():
	...

	def print_tree(self):
		return self.preorder_print(tree.root, "")[:-1]

	def preorder_search_recursive(self, start, find_val):
		if start:
			if start.value == find_val:
				return True
			self.preorder_search_recursive(start.left, find_val)
			self.preorder_search_recursive(start.right, find_val)	
	
	def preorder_print(self, start, traversal):
		if start:
			traversal += (str(start.value) + "-")
			traversal = self.preorder_print(start.left, traversal)
			traversal = self.preorder_print(start.right,traversal)
		return traversal
\end{lstlisting}

\section{Binary Search Trees (BST)}
Performing operations such as search, addition, or removal of an element it is a very efficient process if the binary tree is ordered. A binary tree is ordered if for all nodes the left child has a minor value, and the right child has a greater value than the considered node \cite{wikibinsearchtree}(\href{https://en.wikipedia.org/wiki/Binary_search_tree}{Binary search tree, Wikipedia}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_13.pdf}
		\caption[Search on an ordered binary tree.]{Search on an ordered binary tree.}
		\label{trees_13}
	\end{center}
\end{figure}

For example in Figure \ref{trees_13} is an ordered tree. Let us consider we would like to find the node which value is 7. Because the tree is ordered for efficiently finding 7 is enough to compare 7 with the value of the node and choose every time if to search on the right or on the left. In this way for finding a value is not mandatory to look at all the nodes, and the complexity for this operation is \(log(n)\).

Let us consider instead we would like to add a new node of value 4 to the tree of Figure \ref{trees_13}. Because the tree is ordered, there is only one place in which the node can be added. In the case of the tree in Figure \ref{trees_13} the node can be easily added because there is an empty space that can correctly take it (Figure \ref{trees_14}). In this case the complexity for this operation is again \(log(n)\).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_14.pdf}
		\caption[Addition on an ordered binary tree.]{Addition on an ordered binary tree.}
		\label{trees_14}
	\end{center}
\end{figure}

In case the position of the node is already occupied, adding the node could be a very difficult task. For a more complete and formal description of this topic refer to \cite{goodrich2013data} in the chapter about trees.

When all the possible nodes are present in each level the tree is said \textbf{balanced}. In Figure \ref{trees_14} there is an example of a balanced tree.
When instead a tree has all its children nodes which have always a bigger value, all the tree is on the right, and it is said to be \textbf{unbalanced}. In this case the search of an element has a \(O(n)\) complexity in the worst case.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_15.pdf}
		\caption[An unbalanced binary tree.]{An unbalanced binary tree.}
		\label{trees_15}
	\end{center}
\end{figure}

\subsection{Binary Search Tree Implementation}
The following code is the python implementation of the search and addition operations performed on a ordered binary tree.

\begin{lstlisting}[firstnumber=1, caption={implementation of insert and search operation for a binary search tree.}]
class BST():

	def __int__(self, root):
		self.root = Node(root)

	def insert(self, new_val):
		self.insert_helper(self.root, new_val)
	
	def insert_helper(self, current, new_val):
		if current.value < new_val:
			if current.right:
				self.insert_helper(current.right, new_val)
			else:
				self.current.right = Node(new_val)
		else:
			if current.left:
				self.insert_helper(current.left, new_val)
			else:
				current.left = Node(new_val)
	
	def search(self, find_val):
		return self.search_helper(self.root, find_val)
	
	def search_helper(self, current, find_val):
		if current:
			if current.value == find_val:
				return True
			elif current.value < find_val:
				return self.search_helper(current.right, find_val)
			else:
				return self.search_helper(current.left, find_val)
		return False
\end{lstlisting}

\section{Heaps}
\textbf{Heaps} are particular tree-based data structure in which the elements are ordered in increasing or decreasing order \cite{wikiheap} (\href{https://en.wikipedia.org/wiki/Heap_(data_structure)}{Heap, Wikipedia}). Heaps are a very efficient implementation of the abstract data type (Chapter \ref{chp:datastrucutres}) priority queue (Section \ref{queue}). The value with the highest (or lowest) priority is always stored at the root. Heaps are very useful when an element with a high (or low) priority must be repeatedly removed from the heap. Moreover, heaps are not sorted structure, but are regarded as partially ordered.    

We say the \textit{max heap} (Figure \ref{trees_16} (a)) if for every node its children have the values less or equal than the one of the parent (the root has always the highest value). We say instead \textit{min heap} (Figure \ref{trees_16} (b)) if for every node its children have the values higher or equal than the on of the parent (the root has the lowest value).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_16.pdf}
		\caption[Max heap and min heap example.]{Max heap and min heap example.}
		\label{trees_16}
	\end{center}
\end{figure}

In general heaps are not binary trees so they can have more than two nodes.

In a max heap tree the search of the biggest value is called \textbf{peek} and it has a constant complexity (\(O(1)\)). For searching other values instead we have to check node by node as the ordering of the left and right side is not guarantee. The average case is \(O(\frac{n}{2})\ = \ O(n)\).
\subsection{Heapify}
Let us consider we would like to add a new node to a heap. In this case the node to be add must respect the heap condition. For doing so the node is added in the first available position, and later the node of the heap are swapped in order to keep true the heap condition.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_17.pdf}
		\caption[Add a new node to a heap.]{Add a new node to a heap.}
		\label{trees_17}
	\end{center}
\end{figure}

In the example of Figure \ref{trees_17} only one swap is necessary. The complexity of adding a new element and swap all the node, in order to keep valid the heap condition, is \(log(n)\), and in the worst case the highest number of operations correspond to the height of the tree.

\subsection{Heap Implementation}
To implement a heap we can use an array. An example of this application is shown in the following figure (Figure \ref{trees_18}).

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_18.pdf}
		\caption[Implementation example of a heap using an array.]{Implementation example of a heap using an array.}
		\label{trees_18}
	\end{center}
\end{figure}

\section{Self-balancing Binary Search Trees}
\textbf{Self-balancing binary trees} are binary tree-based structure that automatically maintain the lowest height (number of levels below the root) when an insertion or deletion is done \cite{wikiselfbalancing} (\href{https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree}{Self-balancing binary search tree, Wikipedia}). This structure is an efficient way to implement abstract data type like lists, priority queue, and sets.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_19.pdf}
		\caption[Example of balancing an unbalanced tree.]{Example of balancing an unbalanced tree. Credits: \href{https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree}{Self-balancing binary search tree, Wikipedia}}
		\label{trees_19}
	\end{center}
\end{figure}

In Figure \ref{trees_19} is show an unbalanced tree (case a) in which the average path to reach the leaf is 3.27 nodes. If the same tree is balanced (case b) the average path to reach any leaf from the root decreased to 3.

\section{Red-Black Trees}
The \textbf{red-black trees} are particular kind of self balancing trees. An extra bit is used to store the color of the node, which can be only \textbf{red} or \textbf{black}. Using a color for each node assures that the tree remains balanced during insertion and deletion operations \cite{wikiblackred} (\href{https://en.wikipedia.org/wiki/Red%E2%80%93black_tree}{Red-black tree, Wikipedia}).

The rules that a red-black tree must respect are:
\begin{itemize}
\item[1] Nodes can be only of two types: \textbf{red} or \textbf{black}.
\item[2] There must exist the \textbf{null leaf nodes}. Every node which does not have two leaf must have the children \textbf{null}.
\item[3] If a node is \textbf{red} all its children must be \textbf{black}.
\item[4] Usually the root is \textbf{black}, but this is not mandatory.
\item[5] Every path from a the upper nodes to the lower ones must contain the same number of \textbf{black} nodes. This property is very important when inserting new nodes.
\end{itemize}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_20.pdf}
		\caption[A red-black tree.]{A red-black tree.}
		\label{trees_20}
	\end{center}
\end{figure}

Usual only red nodes are added and the color of the other nodes are changed accordingly in order to respect the rule for the red-black tree.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_21.pdf}
		\caption[Insertion of a new node and the following updating of the color nodes.]{Insertion of a new node and the following updating of the color nodes.}
		\label{trees_21}
	\end{center}
\end{figure}

In case the insertion or the removal does nor respect the rules of the red-black tree and BST some more complex operations must be done as in the following figure.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=.6]{chapters/trees/images/trees_22.pdf}
		\caption[Left and right rotation for balancing the tree after an insertion.]{Left and right rotation for balancing the tree after an insertion.}
		\label{trees_22}
	\end{center}
\end{figure}